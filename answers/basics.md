### Различия ООП и ФП
ООП - это работа с данными через полиморфизм, наследование и инкапсуляцию, а ФП - это работа с данными с помощью функций (чистая функция, функция вышего порядка). 

### Область видимости
Область видимости - это пространство имен переменных с определенным доступом к ним.

### Замыкания
Замыкание - это способность функции запоминать свою лексическую область видимости вне зависимости от того, где она вызывается.

### Императивное/деклоративное программирование
* Императивное - описываю порядок действий.
* Деклоративное - описываю процесс (например, пишу сначала все function declaration, а потом уже пишу код).

### Функция 
Функция - это отдельный блок кода, который можно, один раз объявив, вызывать столько раз, сколько нужно
Все переменные внутри функции – это свойства специального скрытого внутреннего объекта "лексическое окружение" который создаётся при её запуске.

### Прототипное наследование
* Каждый обьект в JS имеет скрытую ссылку на null или на другой обьект, который будет его прототипом.
* Для доступа к прототипу мы можем использовать ссылку __proto__.
* Если мы хотим вызвать метод obj, то поиск будет сначала в obj, а потом в его прототипах.
* Prototype - это обьект, имеющий единственное свойство constructor, ссылающийся на саму функцию. Есть только у функций.
* Цикл for..in пробегается также по унаследованным свойствам. Решается эта проблема так:
```js
var buz = {
  fog: 'stack'
};
for (var name in buz) {
  if (buz.hasOwnProperty(name)) {
    alert('это точно туман (' + name + '). Значение: ' + buz[name]);
  }
  else {
    alert(name); // toString или что-то ещё
  }
}
```

### Стрелочные функции и обычные
Стрелочные функции не могут вызываться через new, не имеют своего контекста и псевдомассива arguments.

### Отличие let от const
* Переменная, обьявленная через var, всплывает (доступна до обьявления) и равна undefined.
* Переменная, обьявленная через var, имеет функциональную область видимости, а через let/const - блочную. Вот хороший пример.
```js
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); 
    }, 1000); 
}; 
```
В данном случае '10' 10 раз, потому что var игнорирует скобки, и переменная i существует лишь 1 раз - и будет равна 10 в момент выполнения тасок (вспомни, что i через var будет доступна даже вне цикла). А при let на каждой итерации будет своя новая переменная, которая будет браться из замыкания. Задачу можно исправить так:
```js
for (var i = 0; i < 10; i++) {
    setTimeout(function(index) {
        return function() {
        console.log(index);
        };
    }(i), 1000);
};
```

### Критический путь рендеринга
Critical Rendering Path или CRP - последовательность, которую нужно пройти браузеру, после получения HTML ответа от сервера. Она делится на 6 этапов:
1. Построение DOM-дерева (напиши console.log(document) и увидишь этот обьект).
2. Построение CSSOM-дерева (аналогично с DOM создается модель стилей).
3. Запуск JavaScript (когда парсер доходит до тега <script>).
4. Создание Render-дерева (это совокупность DOM и CSSOM).
5. Генерация раскладки (размера видимой области).
6. Отрисовка.

### Promise 
```js
typeof Object === "function";
typeof Function === "function";

Object.__proto__ === Object.prototype; // false
Object.__proto__ === Function.prototype; // true
Function.__proto__ === Function.prototype; // true

const o = {};
o.__proto__ = {};
o.__proto__.hasOwnProperty = null;

const p = {};
p.hasOwnProperty();

function f() {}
f.__proto__ === Function.prototype;
f.hasOwnProperty();
f.__proto__.__proto__.hasOwnProperty();
```
### Пример
```js
const x = () => greet;
const greet = 'Hello';
x(); // 'Hello'
```

### Унарные и бинарные операторы

### Приведение типов
* '===' - сравнение без приведения типов.
* '==' - сравнение с приведением типов.
* При сравнении, если одна из переменных не строка, то оба значения приводятся к числу, иначе сравнение будет в алфавитном порядке.

### Всплытие переменных 
```js
var a = 2;
foo(); // foo 'всплывает'
function foo() {
	a = 3;
	console.log(a);	// 3, потому что обьявление a всплывает внутри foo
	var a;
}
console.log(a);	// 2
```
### Контекст вызова
This - это обьект, зависящий от контекста в котором он применяется. Он может динамически изменяться. Назначается в момент вызова.
```js
function foo() {
	console.log(this.bar);
}
var bar = "global";
var obj1 = {
  	bar: "obj1",
  	foo: foo
};
var obj2 = {
		bar: "obj2"
};
foo(); // "global"
obj1.foo();	// "obj1"
foo.call( obj2 ); // "obj2"
new foo(); // undefined, потому что new foo() устанавливает this на абсолютно новый пустой объект и возвращает
// его, а ключа bar в нем не существует
```