## Различия ООП и ФП
ООП - это работа с данными через полиморфизм, наследование и инкапсуляцию, а ФП - это работа с данными с помощью функций (чистая функция, функция вышего порядка). 

## Область видимости
Область видимости - это пространство имен переменных с определенным доступом к ним.

## Замыкания
Замыкание - это способность функции запоминать свою лексическую область видимости вне зависимости от того, где она вызывается.

## Императивное/деклоративное программирование
* Императивное - описываю порядок действий.
* Деклоративное - описываю процесс (например, пишу сначала все function declaration, а потом уже пишу код).

## This
This - это обьект, зависящий от контекста в котором он применяется. Он может динамически изменяться. Назначается в момент вызова.

## Функция 
Функция - это отдельный блок кода, который можно, один раз объявив, вызывать столько раз, сколько нужно
Все переменные внутри функции – это свойства специального скрытого внутреннего объекта "лексическое окружение" который создаётся при её запуске.

## Прототипное наследование
* Каждый обьект в JS имеет скрытую ссылку на null или на другой обьект, который будет его прототипом.
* Для доступа к прототипу мы можем использовать ссылку __proto__.
* Если мы хотим вызвать метод obj, то поиск будет сначала в obj, а потом в его прототипах.
* Prototype - это обьект, имеющий единственное свойство constructor, ссылающийся на саму функцию. Есть только у функций.
* Цикл for..in пробегается также по унаследованным свойствам. Решается эта проблема так:
```var buz = {
  fog: 'stack'
};
for (var name in buz) {
  if (buz.hasOwnProperty(name)) {
    alert('это точно туман (' + name + '). Значение: ' + buz[name]);
  }
  else {
    alert(name); // toString или что-то ещё
  }
}
```

## Стрелочные функции и обычные
Стрелочные функции не имеют this (берется снаружи), arguments и не могут вызываться через new.

## Отличие let от const
* Переменная, обьявленная через var, всплывает (доступна до обьявления) и равна undefined.
* Переменная, обьявленная через var, имеет функциональную область видимости, а через let/const - блочную. Вот хороший пример.
```
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); 
    }, 1000); 
}; 
```
В данном случае '10' 10 раз, потому что var игнорирует скобки, и переменная i существует лишь 1 раз - и будет равна 10 в момент выполнения тасок (вспомни, что i через var будет доступна даже вне цикла). А при let на каждой итерации будет своя новая переменная, которая будет браться из замыкания. Задачу можно исправить так:
```
for (var i = 0; i < 10; i++) {
    setTimeout(function(index) {
        return function() {
        console.log(index);
        };
    }(i), 1000);
};
```